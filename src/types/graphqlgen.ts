// Code generated by github.com/prisma/graphqlgen, DO NOT EDIT.

import { GraphQLResolveInfo } from 'graphql';
import {
  User,
  UserConnection,
  PageInfo,
  UserEdge,
  AggregateUser,
  BatchPayload,
  UserSubscriptionPayload,
  UserPreviousValues,
} from './graphql';
type Context = any;

export type UserOrderByInput =
  | 'id_ASC'
  | 'id_DESC'
  | 'name_ASC'
  | 'name_DESC'
  | 'createdAt_ASC'
  | 'createdAt_DESC'
  | 'updatedAt_ASC'
  | 'updatedAt_DESC';
export type MutationType = 'CREATED' | 'UPDATED' | 'DELETED';

export namespace QueryResolvers {
  export const defaultResolvers = {};

  export interface UserWhereUniqueInput {
    id?: string | null;
  }
  export interface UserWhereInput {
    id?: string | null;
    id_not?: string | null;
    id_in?: string[] | null;
    id_not_in?: string[] | null;
    id_lt?: string | null;
    id_lte?: string | null;
    id_gt?: string | null;
    id_gte?: string | null;
    id_contains?: string | null;
    id_not_contains?: string | null;
    id_starts_with?: string | null;
    id_not_starts_with?: string | null;
    id_ends_with?: string | null;
    id_not_ends_with?: string | null;
    name?: string | null;
    name_not?: string | null;
    name_in?: string[] | null;
    name_not_in?: string[] | null;
    name_lt?: string | null;
    name_lte?: string | null;
    name_gt?: string | null;
    name_gte?: string | null;
    name_contains?: string | null;
    name_not_contains?: string | null;
    name_starts_with?: string | null;
    name_not_starts_with?: string | null;
    name_ends_with?: string | null;
    name_not_ends_with?: string | null;
    AND?: UserWhereInput[] | null;
    OR?: UserWhereInput[] | null;
    NOT?: UserWhereInput[] | null;
  }

  export interface ArgsUser {
    where: UserWhereUniqueInput;
  }

  export interface ArgsUsers {
    where?: UserWhereInput | null;
    orderBy?: UserOrderByInput | null;
    skip?: number | null;
    after?: string | null;
    before?: string | null;
    first?: number | null;
    last?: number | null;
  }

  export interface ArgsUsersConnection {
    where?: UserWhereInput | null;
    orderBy?: UserOrderByInput | null;
    skip?: number | null;
    after?: string | null;
    before?: string | null;
    first?: number | null;
    last?: number | null;
  }

  export interface ArgsNode {
    id: string;
  }

  export type UserResolver = (
    parent: undefined,
    args: ArgsUser,
    ctx: Context,
    info: GraphQLResolveInfo,
  ) => User | null | Promise<User | null>;

  export type UsersResolver = (
    parent: undefined,
    args: ArgsUsers,
    ctx: Context,
    info: GraphQLResolveInfo,
  ) => Array<User | null> | Promise<Array<User | null>>;

  export type UsersConnectionResolver = (
    parent: undefined,
    args: ArgsUsersConnection,
    ctx: Context,
    info: GraphQLResolveInfo,
  ) => UserConnection | Promise<UserConnection>;

  export type NodeResolver = (
    parent: undefined,
    args: ArgsNode,
    ctx: Context,
    info: GraphQLResolveInfo,
  ) => {} | null | Promise<{} | null>;

  export interface Type {
    user: (
      parent: undefined,
      args: ArgsUser,
      ctx: Context,
      info: GraphQLResolveInfo,
    ) => User | null | Promise<User | null>;

    users: (
      parent: undefined,
      args: ArgsUsers,
      ctx: Context,
      info: GraphQLResolveInfo,
    ) => Array<User | null> | Promise<Array<User | null>>;

    usersConnection: (
      parent: undefined,
      args: ArgsUsersConnection,
      ctx: Context,
      info: GraphQLResolveInfo,
    ) => UserConnection | Promise<UserConnection>;

    node: (
      parent: undefined,
      args: ArgsNode,
      ctx: Context,
      info: GraphQLResolveInfo,
    ) => {} | null | Promise<{} | null>;
  }
}

export namespace UserResolvers {
  export const defaultResolvers = {
    id: (parent: User) => parent.id,
    name: (parent: User) => parent.name,
  };

  export type IdResolver = (
    parent: User,
    args: {},
    ctx: Context,
    info: GraphQLResolveInfo,
  ) => string | Promise<string>;

  export type NameResolver = (
    parent: User,
    args: {},
    ctx: Context,
    info: GraphQLResolveInfo,
  ) => string | Promise<string>;

  export interface Type {
    id: (
      parent: User,
      args: {},
      ctx: Context,
      info: GraphQLResolveInfo,
    ) => string | Promise<string>;

    name: (
      parent: User,
      args: {},
      ctx: Context,
      info: GraphQLResolveInfo,
    ) => string | Promise<string>;
  }
}

export namespace UserConnectionResolvers {
  export const defaultResolvers = {};

  export type PageInfoResolver = (
    parent: UserConnection,
    args: {},
    ctx: Context,
    info: GraphQLResolveInfo,
  ) => PageInfo | Promise<PageInfo>;

  export type EdgesResolver = (
    parent: UserConnection,
    args: {},
    ctx: Context,
    info: GraphQLResolveInfo,
  ) => Array<UserEdge | null> | Promise<Array<UserEdge | null>>;

  export type AggregateResolver = (
    parent: UserConnection,
    args: {},
    ctx: Context,
    info: GraphQLResolveInfo,
  ) => AggregateUser | Promise<AggregateUser>;

  export interface Type {
    pageInfo: (
      parent: UserConnection,
      args: {},
      ctx: Context,
      info: GraphQLResolveInfo,
    ) => PageInfo | Promise<PageInfo>;

    edges: (
      parent: UserConnection,
      args: {},
      ctx: Context,
      info: GraphQLResolveInfo,
    ) => Array<UserEdge | null> | Promise<Array<UserEdge | null>>;

    aggregate: (
      parent: UserConnection,
      args: {},
      ctx: Context,
      info: GraphQLResolveInfo,
    ) => AggregateUser | Promise<AggregateUser>;
  }
}

export namespace PageInfoResolvers {
  export const defaultResolvers = {
    hasNextPage: (parent: PageInfo) => parent.hasNextPage,
    hasPreviousPage: (parent: PageInfo) => parent.hasPreviousPage,
    startCursor: (parent: PageInfo) =>
      parent.startCursor === undefined ? null : parent.startCursor,
    endCursor: (parent: PageInfo) =>
      parent.endCursor === undefined ? null : parent.endCursor,
  };

  export type HasNextPageResolver = (
    parent: PageInfo,
    args: {},
    ctx: Context,
    info: GraphQLResolveInfo,
  ) => boolean | Promise<boolean>;

  export type HasPreviousPageResolver = (
    parent: PageInfo,
    args: {},
    ctx: Context,
    info: GraphQLResolveInfo,
  ) => boolean | Promise<boolean>;

  export type StartCursorResolver = (
    parent: PageInfo,
    args: {},
    ctx: Context,
    info: GraphQLResolveInfo,
  ) => string | null | Promise<string | null>;

  export type EndCursorResolver = (
    parent: PageInfo,
    args: {},
    ctx: Context,
    info: GraphQLResolveInfo,
  ) => string | null | Promise<string | null>;

  export interface Type {
    hasNextPage: (
      parent: PageInfo,
      args: {},
      ctx: Context,
      info: GraphQLResolveInfo,
    ) => boolean | Promise<boolean>;

    hasPreviousPage: (
      parent: PageInfo,
      args: {},
      ctx: Context,
      info: GraphQLResolveInfo,
    ) => boolean | Promise<boolean>;

    startCursor: (
      parent: PageInfo,
      args: {},
      ctx: Context,
      info: GraphQLResolveInfo,
    ) => string | null | Promise<string | null>;

    endCursor: (
      parent: PageInfo,
      args: {},
      ctx: Context,
      info: GraphQLResolveInfo,
    ) => string | null | Promise<string | null>;
  }
}

export namespace UserEdgeResolvers {
  export const defaultResolvers = {
    cursor: (parent: UserEdge) => parent.cursor,
  };

  export type NodeResolver = (
    parent: UserEdge,
    args: {},
    ctx: Context,
    info: GraphQLResolveInfo,
  ) => User | Promise<User>;

  export type CursorResolver = (
    parent: UserEdge,
    args: {},
    ctx: Context,
    info: GraphQLResolveInfo,
  ) => string | Promise<string>;

  export interface Type {
    node: (
      parent: UserEdge,
      args: {},
      ctx: Context,
      info: GraphQLResolveInfo,
    ) => User | Promise<User>;

    cursor: (
      parent: UserEdge,
      args: {},
      ctx: Context,
      info: GraphQLResolveInfo,
    ) => string | Promise<string>;
  }
}

export namespace AggregateUserResolvers {
  export const defaultResolvers = {
    count: (parent: AggregateUser) => parent.count,
  };

  export type CountResolver = (
    parent: AggregateUser,
    args: {},
    ctx: Context,
    info: GraphQLResolveInfo,
  ) => number | Promise<number>;

  export interface Type {
    count: (
      parent: AggregateUser,
      args: {},
      ctx: Context,
      info: GraphQLResolveInfo,
    ) => number | Promise<number>;
  }
}

export namespace MutationResolvers {
  export const defaultResolvers = {};

  export interface UserCreateInput {
    name: string;
  }
  export interface UserUpdateInput {
    name?: string | null;
  }
  export interface UserWhereUniqueInput {
    id?: string | null;
  }
  export interface UserUpdateManyMutationInput {
    name?: string | null;
  }
  export interface UserWhereInput {
    id?: string | null;
    id_not?: string | null;
    id_in?: string[] | null;
    id_not_in?: string[] | null;
    id_lt?: string | null;
    id_lte?: string | null;
    id_gt?: string | null;
    id_gte?: string | null;
    id_contains?: string | null;
    id_not_contains?: string | null;
    id_starts_with?: string | null;
    id_not_starts_with?: string | null;
    id_ends_with?: string | null;
    id_not_ends_with?: string | null;
    name?: string | null;
    name_not?: string | null;
    name_in?: string[] | null;
    name_not_in?: string[] | null;
    name_lt?: string | null;
    name_lte?: string | null;
    name_gt?: string | null;
    name_gte?: string | null;
    name_contains?: string | null;
    name_not_contains?: string | null;
    name_starts_with?: string | null;
    name_not_starts_with?: string | null;
    name_ends_with?: string | null;
    name_not_ends_with?: string | null;
    AND?: UserWhereInput[] | null;
    OR?: UserWhereInput[] | null;
    NOT?: UserWhereInput[] | null;
  }

  export interface ArgsCreateUser {
    data: UserCreateInput;
  }

  export interface ArgsUpdateUser {
    data: UserUpdateInput;
    where: UserWhereUniqueInput;
  }

  export interface ArgsUpdateManyUsers {
    data: UserUpdateManyMutationInput;
    where?: UserWhereInput | null;
  }

  export interface ArgsUpsertUser {
    where: UserWhereUniqueInput;
    create: UserCreateInput;
    update: UserUpdateInput;
  }

  export interface ArgsDeleteUser {
    where: UserWhereUniqueInput;
  }

  export interface ArgsDeleteManyUsers {
    where?: UserWhereInput | null;
  }

  export type CreateUserResolver = (
    parent: undefined,
    args: ArgsCreateUser,
    ctx: Context,
    info: GraphQLResolveInfo,
  ) => User | Promise<User>;

  export type UpdateUserResolver = (
    parent: undefined,
    args: ArgsUpdateUser,
    ctx: Context,
    info: GraphQLResolveInfo,
  ) => User | null | Promise<User | null>;

  export type UpdateManyUsersResolver = (
    parent: undefined,
    args: ArgsUpdateManyUsers,
    ctx: Context,
    info: GraphQLResolveInfo,
  ) => BatchPayload | Promise<BatchPayload>;

  export type UpsertUserResolver = (
    parent: undefined,
    args: ArgsUpsertUser,
    ctx: Context,
    info: GraphQLResolveInfo,
  ) => User | Promise<User>;

  export type DeleteUserResolver = (
    parent: undefined,
    args: ArgsDeleteUser,
    ctx: Context,
    info: GraphQLResolveInfo,
  ) => User | null | Promise<User | null>;

  export type DeleteManyUsersResolver = (
    parent: undefined,
    args: ArgsDeleteManyUsers,
    ctx: Context,
    info: GraphQLResolveInfo,
  ) => BatchPayload | Promise<BatchPayload>;

  export interface Type {
    createUser: (
      parent: undefined,
      args: ArgsCreateUser,
      ctx: Context,
      info: GraphQLResolveInfo,
    ) => User | Promise<User>;

    updateUser: (
      parent: undefined,
      args: ArgsUpdateUser,
      ctx: Context,
      info: GraphQLResolveInfo,
    ) => User | null | Promise<User | null>;

    updateManyUsers: (
      parent: undefined,
      args: ArgsUpdateManyUsers,
      ctx: Context,
      info: GraphQLResolveInfo,
    ) => BatchPayload | Promise<BatchPayload>;

    upsertUser: (
      parent: undefined,
      args: ArgsUpsertUser,
      ctx: Context,
      info: GraphQLResolveInfo,
    ) => User | Promise<User>;

    deleteUser: (
      parent: undefined,
      args: ArgsDeleteUser,
      ctx: Context,
      info: GraphQLResolveInfo,
    ) => User | null | Promise<User | null>;

    deleteManyUsers: (
      parent: undefined,
      args: ArgsDeleteManyUsers,
      ctx: Context,
      info: GraphQLResolveInfo,
    ) => BatchPayload | Promise<BatchPayload>;
  }
}

export namespace BatchPayloadResolvers {
  export const defaultResolvers = {
    count: (parent: BatchPayload) => parent.count,
  };

  export type CountResolver = (
    parent: BatchPayload,
    args: {},
    ctx: Context,
    info: GraphQLResolveInfo,
  ) => string | Promise<string>;

  export interface Type {
    count: (
      parent: BatchPayload,
      args: {},
      ctx: Context,
      info: GraphQLResolveInfo,
    ) => string | Promise<string>;
  }
}

export namespace SubscriptionResolvers {
  export const defaultResolvers = {};

  export interface UserSubscriptionWhereInput {
    mutation_in?: MutationType[] | null;
    updatedFields_contains?: string | null;
    updatedFields_contains_every?: string[] | null;
    updatedFields_contains_some?: string[] | null;
    node?: UserWhereInput | null;
    AND?: UserSubscriptionWhereInput[] | null;
    OR?: UserSubscriptionWhereInput[] | null;
    NOT?: UserSubscriptionWhereInput[] | null;
  }
  export interface UserWhereInput {
    id?: string | null;
    id_not?: string | null;
    id_in?: string[] | null;
    id_not_in?: string[] | null;
    id_lt?: string | null;
    id_lte?: string | null;
    id_gt?: string | null;
    id_gte?: string | null;
    id_contains?: string | null;
    id_not_contains?: string | null;
    id_starts_with?: string | null;
    id_not_starts_with?: string | null;
    id_ends_with?: string | null;
    id_not_ends_with?: string | null;
    name?: string | null;
    name_not?: string | null;
    name_in?: string[] | null;
    name_not_in?: string[] | null;
    name_lt?: string | null;
    name_lte?: string | null;
    name_gt?: string | null;
    name_gte?: string | null;
    name_contains?: string | null;
    name_not_contains?: string | null;
    name_starts_with?: string | null;
    name_not_starts_with?: string | null;
    name_ends_with?: string | null;
    name_not_ends_with?: string | null;
    AND?: UserWhereInput[] | null;
    OR?: UserWhereInput[] | null;
    NOT?: UserWhereInput[] | null;
  }

  export interface ArgsUser {
    where?: UserSubscriptionWhereInput | null;
  }

  export interface UserResolver {
    subscribe: (
      parent: undefined,
      args: ArgsUser,
      ctx: Context,
      info: GraphQLResolveInfo,
    ) =>
      | AsyncIterator<UserSubscriptionPayload | null>
      | Promise<AsyncIterator<UserSubscriptionPayload | null>>;
    resolve?: (
      parent: undefined,
      args: ArgsUser,
      ctx: Context,
      info: GraphQLResolveInfo,
    ) =>
      | UserSubscriptionPayload
      | null
      | Promise<UserSubscriptionPayload | null>;
  }

  export interface Type {
    user: {
      subscribe: (
        parent: undefined,
        args: ArgsUser,
        ctx: Context,
        info: GraphQLResolveInfo,
      ) =>
        | AsyncIterator<UserSubscriptionPayload | null>
        | Promise<AsyncIterator<UserSubscriptionPayload | null>>;
      resolve?: (
        parent: undefined,
        args: ArgsUser,
        ctx: Context,
        info: GraphQLResolveInfo,
      ) =>
        | UserSubscriptionPayload
        | null
        | Promise<UserSubscriptionPayload | null>;
    };
  }
}

export namespace UserSubscriptionPayloadResolvers {
  export const defaultResolvers = {
    updatedFields: (parent: UserSubscriptionPayload) => parent.updatedFields,
  };

  export type MutationResolver = (
    parent: UserSubscriptionPayload,
    args: {},
    ctx: Context,
    info: GraphQLResolveInfo,
  ) => MutationType | Promise<MutationType>;

  export type NodeResolver = (
    parent: UserSubscriptionPayload,
    args: {},
    ctx: Context,
    info: GraphQLResolveInfo,
  ) => User | null | Promise<User | null>;

  export type UpdatedFieldsResolver = (
    parent: UserSubscriptionPayload,
    args: {},
    ctx: Context,
    info: GraphQLResolveInfo,
  ) => string[] | null | Promise<string[] | null>;

  export type PreviousValuesResolver = (
    parent: UserSubscriptionPayload,
    args: {},
    ctx: Context,
    info: GraphQLResolveInfo,
  ) => UserPreviousValues | null | Promise<UserPreviousValues | null>;

  export interface Type {
    mutation: (
      parent: UserSubscriptionPayload,
      args: {},
      ctx: Context,
      info: GraphQLResolveInfo,
    ) => MutationType | Promise<MutationType>;

    node: (
      parent: UserSubscriptionPayload,
      args: {},
      ctx: Context,
      info: GraphQLResolveInfo,
    ) => User | null | Promise<User | null>;

    updatedFields: (
      parent: UserSubscriptionPayload,
      args: {},
      ctx: Context,
      info: GraphQLResolveInfo,
    ) => string[] | null | Promise<string[] | null>;

    previousValues: (
      parent: UserSubscriptionPayload,
      args: {},
      ctx: Context,
      info: GraphQLResolveInfo,
    ) => UserPreviousValues | null | Promise<UserPreviousValues | null>;
  }
}

export namespace UserPreviousValuesResolvers {
  export const defaultResolvers = {
    id: (parent: UserPreviousValues) => parent.id,
    name: (parent: UserPreviousValues) => parent.name,
  };

  export type IdResolver = (
    parent: UserPreviousValues,
    args: {},
    ctx: Context,
    info: GraphQLResolveInfo,
  ) => string | Promise<string>;

  export type NameResolver = (
    parent: UserPreviousValues,
    args: {},
    ctx: Context,
    info: GraphQLResolveInfo,
  ) => string | Promise<string>;

  export interface Type {
    id: (
      parent: UserPreviousValues,
      args: {},
      ctx: Context,
      info: GraphQLResolveInfo,
    ) => string | Promise<string>;

    name: (
      parent: UserPreviousValues,
      args: {},
      ctx: Context,
      info: GraphQLResolveInfo,
    ) => string | Promise<string>;
  }
}

export interface Resolvers {
  Query: QueryResolvers.Type;
  User: UserResolvers.Type;
  UserConnection: UserConnectionResolvers.Type;
  PageInfo: PageInfoResolvers.Type;
  UserEdge: UserEdgeResolvers.Type;
  AggregateUser: AggregateUserResolvers.Type;
  Mutation: MutationResolvers.Type;
  BatchPayload: BatchPayloadResolvers.Type;
  Subscription: SubscriptionResolvers.Type;
  UserSubscriptionPayload: UserSubscriptionPayloadResolvers.Type;
  UserPreviousValues: UserPreviousValuesResolvers.Type;
}
